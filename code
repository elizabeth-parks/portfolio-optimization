# -*- coding: utf-8 -*-
"""Copy of BGAGroup1ProjectCode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xr6pqofoJOpQWAQTRAqFJ8tQrnRSujcX
"""

#Import the required libraries
from pandas_datareader import data as web
import pandas as pd
import yfinance as yf  #added this library to fix cell 7
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

#Get number of stocks, and tickers from user, check that the ticker is valid
def get_valid_stock(prompt):
    while True:
        stock = input(prompt).upper()
        ticker = yf.Ticker(stock)
        try:
            # Check if we can retrieve any basic info (e.g., name) to verify it's valid
            if ticker.info and 'shortName' in ticker.info:
                return stock
            else:
                print(f"{stock} is not a valid ticker. Please try again.")
        except Exception as e:
            print(f"Error retrieving data for {stock}. Please try again.")

# Ask the user for the number of stocks they want to enter
num_stocks = int(input("How many stocks would you like to enter?\n"))

# Collect valid stock tickers based on the chosen number
assets = []
for i in range(num_stocks):
    stock = get_valid_stock(f"What is the stock ticker for stock #{i+1}?\n")
    assets.append(stock)

print("Validated assets:", assets)

# Function to get weights from the user and ensure they sum to 1
def get_weights(num_stocks):
    weights = []
    for i in range(num_stocks):
        while True:
            try:
                weight = float(input(f"Enter the weight for stock #{i+1} (in decimal form, e.g., 0.2 for 20%): "))
                if 0 <= weight <= 1:
                    weights.append(weight)
                    break
                else:
                    print("Please enter a weight between 0 and 1.")
            except ValueError:
                print("Invalid input. Please enter a decimal number.")

    # Check if weights sum to 1
    if sum(weights) != 1:
        print("The weights you entered do not sum to 1. Please try again.")
        return get_weights(num_stocks)  # Restart if sum is incorrect
    return np.array(weights)

# Get weights from the user
weights = get_weights(num_stocks)
print("Assigned weights:", weights)

#Get the stock/portfolio start date
stockStartDate = datetime(2013, 1, 1)
today = datetime.today().strftime("%Y-%m-%d")
today

#create a dataframe to store the adjusted close price of the stocks
df = pd.DataFrame()

for stock in assets:
    try:
        df[stock] = yf.download(stock, start=stockStartDate, end=today)['Close']
    except Exception as e:
        print(f"Error fetching data for {stock}: {e}")

#show the df
df

#Plot the adjusted close price history
title = "Portfolio Close Price History"
my_stocks = df

plt.figure(figsize=(10, 6))
for c in my_stocks.columns.values:
    plt.plot(my_stocks[c], label=c)

plt.title(title)
plt.xlabel('Date', fontsize=18)
plt.ylabel('Price USD ($)', fontsize=18)
plt.legend(my_stocks.columns.values, loc='upper left')
plt.show()

#show the daily simple return
returns = df.pct_change()
returns

#create and show anualized covariance matrix
cov_matrix_annual = returns.cov() * 252
cov_matrix_annual

#calculate the portfolio variance
port_variance = np.dot(weights.T, np.dot(cov_matrix_annual, weights))
port_variance

#Calculate the portfolio volitility
port_volatility = np.sqrt(port_variance)
port_volatility

#calculate the annual portfolio return
portfolioSimpleAnnualReturn = np.sum(returns.mean() * weights) * 252
portfolioSimpleAnnualReturn

#Show the expected annual return, volatility (risk), and variance
percent_var = str(round(port_variance, 2) * 100) + '%'
percent_vols = str(round(port_volatility, 2) * 100) + '%'
percent_ret = str(round(portfolioSimpleAnnualReturn, 2) * 100) + '%'

print("Expected annual return: " + percent_ret)
print("Annual Volatility / risk: " + percent_vols)
print("Annual Variance: " + percent_var)

pip install PyPortfolioOpt

from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns

#Portfolio Optimization

#Calculate expected returns and the annualized sample covariance matrix of asset returns
mu = expected_returns.mean_historical_return(df)
S = risk_models.sample_cov(df)

#Optimize for max Sharpe ratio
ef = EfficientFrontier(mu, S)
weights = ef.max_sharpe()
cleaned_weights = ef.clean_weights()
print(cleaned_weights)
ef.portfolio_performance(verbose=True)

#Get the discrete allocation of each share per stock
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

latest_prices = get_latest_prices(df)
weights = cleaned_weights

# Ask the user for the total portfolio value
try:
    total_portfolio_value = float(input("Enter the amount of money you want to invest in your portfolio: $"))
except ValueError:
    print("Invalid input! Please enter a numeric value.")
    exit()

da = DiscreteAllocation(weights, latest_prices, total_portfolio_value)

allocation, leftover = da.lp_portfolio()
print('Discrete allocation:', allocation)
print('Funds remaining: ${:.2f}'.format(leftover))

#This code block adds optimization for sorintino ratio

from scipy.optimize import minimize

# Set parameters
risk_free_rate = 0.01  # Adjust as per the current risk-free rate

# Define the Sortino Ratio calculation function
def sortino_ratio(weights, returns, risk_free_rate=0.01):
    portfolio_return = np.sum(returns.mean() * weights) * 252  # Annualized return
    downside_returns = returns[returns < 0].fillna(0)  # Only consider negative returns
    downside_risk = np.sqrt(np.mean((downside_returns.dot(weights)) ** 2)) * np.sqrt(252)  # Annualized downside risk

    sortino = (portfolio_return - risk_free_rate) / downside_risk
    return -sortino  # Negative for minimization

# Constraints: weights sum to 1
def weight_constraint(weights):
    return np.sum(weights) - 1


# Convert the 'weights' OrderedDict to a list for optimization
initial_weights = list(weights.values())
# bounds should have the same length as initial_weights
bounds = [(0, 1) for _ in range(len(initial_weights))]


# Run the optimization
# Change: Pass initial_weights instead of weights to minimize
optimized_result = minimize(
    sortino_ratio,
    initial_weights,  # Pass the list of initial weights here
    args=(returns, risk_free_rate),
    method='SLSQP',
    bounds=bounds,
    constraints={'type': 'eq', 'fun': weight_constraint}
)

# Extract optimized weights
optimized_weights = optimized_result.x
optimized_sortino = -optimized_result.fun  # Get positive Sortino Ratio

print("Optimized Portfolio Weights:", optimized_weights)
print("Maximized Sortino Ratio:", optimized_sortino)

#Get the discrete allocation of each share per stock
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

latest_prices = get_latest_prices(df)

# Convert optimized_weights (NumPy array) to a dictionary
weights = dict(zip(df.columns, optimized_weights)) # df.columns provides the tickers

# Ask the user for the total portfolio value
try:
    total_portfolio_value = float(input("Enter the amount of money you want to invest in your portfolio: $"))
except ValueError:
    print("Invalid input! Please enter a numeric value.")
    exit()

# Pass optimized_weights to DiscreteAllocation
da = DiscreteAllocation(weights, latest_prices, total_portfolio_value)

allocation, leftover = da.lp_portfolio()
print('Discrete allocation:', allocation)
print('Funds remaining: ${:.2f}'.format(leftover))
